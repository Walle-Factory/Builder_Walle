# redis作用

- 分布式锁
- 支持事务
- 持久化
- LUA脚本
- LRU驱动事件
- 多种集群方案



# 为什么使用redis

## 高性能

- 直接操作内存（缓存），速度快

## 高并发

- 直接操作缓存的承受能力远远大于直接访问数据库。用户的部分请求可以直接到缓存拿，不经过数据库。

# redis线程模型

- 内部使用 **文件事件处理器** （file event handler） ,是单线程的，所以redis才叫做单线程模型。
- 采用IO多路复用机制，同时监听多个socket,根据socket上的事件来选择对应事件处理器进行处理。（文件事件处理器的结构包含4各部分）
  - 多个socket
  - IO多里复用程序
  - 文件事件分派器
  - 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
-  多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。 

# redis和 memcached区别

- redis支持更丰富的数据类型（更复杂的应用场景）：不仅仅支持简单的k/v类型数据，还提供list,set,hash,zset数据结构存储。而memcached仅支持string类型。
- redis支持持久化，可以把数据保存在磁盘中，重启的时候，可以重新加载使用，而memcached把数据全放在内存中。
- 关于集群模式：memcached没有原生的集群模式，需要依靠客户端实现往集群中分片写入数据；但是redis目前支持原生的cluster模式。
- memcached是多线程，非阻塞IO复用网络模型；redis使用单线程的多路IO复用。

# redis设置过期时间

- set key时，加上 expire time
- 删除
  - 定期删除
  - 惰性删除

# redis内存淘汰机制

- volatile-lru: 从已设置过期时间数据集中挑选最少使用的数据。
- volatile-ttl:从已设置过期时间数据集中挑选将要过期的数据
- volatile-random:从已设置过期时间数据集中随机选择数据淘汰。
- allkeys-lru:当内存不足以容纳写入新数据时，在键空间中，移除最近最少使用的key
- allkeys-random:从数据集中任意选择数据淘汰
- no-eviction:禁止驱逐数据，当内存不足写入新数据时，新写入时会报错。
- volatile-lfu:从已设置过去时间数据集中选最不经常使用的数据淘汰
- allkeys-lfu:当内存不足以容纳写入新数据时，在键空间淘汰最不经常使用的key

# redis 持久化机制（数据恢复）

## 快照持久化（RDB）

- 是redis默认的持久化方式    ( save 300 10) 在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 
- 通过创建快照来获得某个时间点存储在内存的数据副本。可以进行备份，把快照复制放在其他服务器，并可以创建具有相同数据的服务器副本（redis主从结构），还可将利用快照以便重启服务器使用。

## AOF持久化

- AOF持久化的实时性更好，是个主流的方案，可以通过appendonly参数开启： appendonly yes
- 每执行一条更改数据的命令时，就会将该命令写入硬盘的AOF文件中;AOF和RDB的**文件位置相同**。都是通过dir参数设置的，默认文件名：appendonly.aof

###  **Redis 4.0 对于持久化机制的优化** 

- 4.0支持RDB和AOF混合持久化（通过aof-use-rdb-preamble开启）。
- 混合开启后，AOF重写就直接把RDB内容写入到AOF文件开头。**好处是**：可以结合双方优点，快速加载，避免丢失过多数据。**缺点是：**压缩的格式不是AOF格式，可读性较差。

# redis事务

- redis通过multi,exec,watch等命令实现事务
- 事务提供将多个命令请求打包，然后一次性，按顺序执行
- 在执行期间，服务器**不会中断**事务去执行其他命令

# redis缓存穿透和缓存雪崩

## 缓存雪崩

- 缓存同一时间大面积失效，后面请求都到了数据库，造成数据库短时间承受大量请求而崩掉。

### 解决方法

- 事前：创建redis集群，保证高可用，发现宕机尽快补上，选择合适内存淘汰机制。
- 事中：本地ehcache缓存+hystrix限流&降级。
- 事后：使用redis持久化保存数据尽快恢复。

## 缓存穿透

- 大量请求的key不在缓存中，导致请求直接到了数据库，没有经过缓存。

### 解决方法

- 缓存无效key,查不到某个key数据时，就写入一个到redis中并设置过期时间（set key value EX 10086）
- **布隆过滤器**：是一种数据结构，可以方便判断一个给定数据是否存在海量数据中，我们首先需要判断key是否合法。

# redis并发竞争key

- 多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，导致了结果的不同。

## 解决方法

- 分布式锁：**zookeeper（推荐）**和redis都可实现分布式锁（分布式锁会影响性能）

- 基于zookeeper临时有序节点可以实现分布式锁，思想为：每个客户端对某个方法加锁时，在zookeeper上与该方法对应的指定节点目录下，生成一个唯一瞬时有序节点。
- 判断获取锁的方式，只需判断有序节点中序号最小的一个，当释放锁时，将这个瞬时节点删除即可，同时，还可以避免服务宕机导致锁无法释放而产生死锁的问题。
- 完成业务流程后，删除对应的子节点释放锁。

# 保证缓存与数据库双写的数据一致性

-  如果系统**不是严格要求** “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：**读请求和写请求串行化**，串到一个**内存队列**里去（ 会导致系统的吞吐量大幅度降低 ）。 

## Cache Aside Pattern

- 读的时候，先读缓存，缓存没有的话再读数据库，然后取出数据放入缓存，同时返回响应。
- 更新的时候，先更新数据库再**删除缓存**。

### 为啥要删除缓存

- 可以节省操作时间

