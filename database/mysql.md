# MySQL

## 存储引擎

### MyISAM

* 优点：全文索引，空间，空间函数。
* 缺点：不支持事务，行级锁，不支持外键。

## 数据库事务

可能出现的问题

1. 脏读
2. 丢失修改
3. 不可重复读
4. 幻读

事务隔离级别（可能引起的问题）

1. 读取未提交  ->脏读，幻读，不可重复读
2. 读取已提交  ->不可重复读，幻读
3. 可重复读（InnoDb默认隔离级别）      ->幻读 
4. 可串行化

## 表优化

1. 限制读取数据范围

2. 读写分离

3. 垂直分区

   （1） 优点：使列数据变小，减少数据的block数，减少i/o数，简化表结构，易于维护。

   （2） 缺点 :  表主键冗余，引起较多的join操作，使事务变得复杂。

4. 水平分区

   （1） 优点：可支持非常大的数据量，应用端改造少，

   （2） 缺点 : 分片事务难解决，跨节点join性能较差，逻辑复杂。部署，运维复杂

   （3） 分片的两种方案：

   ​		A : 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 			Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。

   ​		B : 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360			的Atlas、网易的DDB等等都是这种架构的实现。 

## 连接池

1. 优点：初始预设资源，抵消每次获取资源的消耗。创建开销，远程链接开销。



## 分库分表后，id处理

1. uuid

2. 数据库自增

3. redis生成

4. snowflake（雪花算法）：

   * snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。 
   * 是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这					   种方案把64-bit分别划分成多段，分开来标示机器、时间等。
   * 使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号，最后还有一个符号位，永远是0。 
   * 整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右
   * 缺点：强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。

   ​					

5. 美团的Leaf分布式ID生成系统

## 索引

### 优点

1. 加大数据检索速度。
2. 创建唯一索引，保证每一行数据的唯一性。
3. 帮助服务器避免排序和临时表。
4. 把随机io变成顺序io。
5. 加速表与表之间的连接。



### 缺点

1. 占用物理空间。
2. 创建索引和维护索引需要消耗时间。



### 基础知识

1. MySQL基础数据存储结构是页。
2. 每个数据页之间组成双向链表，数据页中的记录又可以组成单向链表。
   * 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录 
   * 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录



### 提交检索速度

1. 将无序的数据相对变成有序的。
2. 如果没有索引需要遍历双向链表定位对应的页，现在通过‘目录’可以很快定位到对应的页上。



### 降低检索速度

1. MySQL底层结构是B+tree,是平衡树（ 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 ）的一种，不会退化成链表树高相对较低，对它进行增删改时，会破坏原有结构。
2. 维持平衡树，需要额外的开销，降低速度。



### 哈希索引

1. 采用哈希算法，将键值换算成新的key, 检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可**立刻定位到相应的位置，速度非常快**。 
2. 本质上就是把健值换算成新的哈希值，根据哈希值定位。
3. 哈希索引短板
   * 没办法利用索引进行排序。
   * 不支持最左匹配原则。
   * 有大量健值情况下，效率低->因为哈希碰撞。
   * 不支持范围查询

### 聚集索引、非聚集索引和覆盖索引

1. 聚集：以主键创建的索引。（页节点->表中数据）
2. 非聚集：非主键创建的索引。（页节点->索引列+主键） **拿到叶子上的主键再去查到想要查找的数据** （回表）
3. 创建多个单列（非聚集）索引时，会生成索引树（消耗空间）
4. 覆盖索引：查出的列和索引时对应的，不需要回表操作。



### 最左匹配原则

1. 索引可以简单如一个列`(a)`，也可以复杂如多个列`(a, b, c, d)`，即**联合索引**。

2. 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询`(>、<、between、like`左匹配)等就**不能进一步匹配**了，后续退化为线性查找。

3. 因此，**列的排列顺序决定了可命中索引的列数**。

4. 例子：如有索引`(a, b, c, d)`，查询条件`a = 1 and b = 2 and c > 3 and d = 4`，则会在每个节点依次  命 中a、b、c，无法命中d。(很简单：索引命中只能是**相等**的情况，不能是范围匹配)

5. **不需要考虑=、in等的顺序**，MySQL会自动优化这些条件的顺序，以匹配尽可能多的索引列。

   例子：

   - 如有索引`(a, b, c, d)`，查询条件`c > 3 and b = 2 and a = 1 and d < 4`与`a = 1 and c > 3 and b = 2 and d < 4`等顺序都是可以的，MySQL会自动优化为`a = 1 and b = 2 and c > 3 and d < 4`，依次命中a、b、c。